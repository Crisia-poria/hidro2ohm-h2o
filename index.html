<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hidro2Ohm</title>
  <style>
    /* Reset e Base */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: #050505;
      color: #e0e0e0;
      font-family: 'Courier New', Courier, monospace; /* Monospace para ar técnico */
      overflow: hidden; /* Impede scroll, foca na imersão */
      height: 100vh;
      width: 100vw;
      position: relative;
    }

    /* Canvas (Campo de Distorção) */
    canvas#field {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      display: block;
    }

    /* Conteúdo (Sobreposição) */
    main#content {
      position: relative;
      z-index: 2;
      height: 100%;
      width: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto; /* Ajustado para topo fixo - meio livre - base fixa */
      pointer-events: none; /* Deixa o mouse passar para o canvas */
    }

    /* Seção Superior (O Texto) */
    #central {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      text-align: center;
      padding-top: 1.5rem; /* Margem do topo */
      width: 100%;
    }

    .dilema {
      /* Estilo de linha de status minimalista */
      font-size: 0.75rem; /* Bem menor */
      font-weight: 400;
      letter-spacing: 0.05em;
      color: rgba(224, 224, 224, 0.6); /* Cinza discreto */
      background: rgba(0, 0, 0, 0.4);
      padding: 0.4rem 1rem;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(2px);
      white-space: nowrap; /* Garante uma linha */
      text-transform: uppercase; /* Estilo técnico */
      display: flex;
      align-items: center;
    }

    .h2o-tag {
      color: #fff;
      font-weight: 700;
      font-size: 0.9em;
      margin-right: 10px;
      opacity: 0.9;
    }

    /* Lateral (Os Dados e Controles) */
    aside#lateral {
      display: flex;
      justify-content: center; 
      align-items: center;
      gap: 3rem; 
      padding: 2rem;
      padding-bottom: 3rem;
      font-family: 'Inter', sans-serif;
      font-size: 0.9rem;
      background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
      pointer-events: auto; /* Permite interagir com o slider */
    }

    /* Containers de estatística */
    .stat-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 100px;
    }

    /* Container do Slider */
    .control-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 140px;
    }
    
    aside#lateral span, 
    .control-box label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #888;
      margin-bottom: 0.5rem;
    }

    aside#lateral strong {
      font-size: 1.2rem;
      font-weight: 400;
      font-variant-numeric: tabular-nums; 
      color: #fff;
      transition: all 0.2s ease-out; 
    }

    /* Estilização do Range Input */
    input[type=range] {
      -webkit-appearance: none;
      width: 100%;
      background: transparent;
    }

    input[type=range]:focus {
      outline: none;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 14px;
      width: 14px;
      border-radius: 50%;
      background: #e0e0e0;
      cursor: pointer;
      margin-top: -6px;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      border: 1px solid #000;
    }

    input[type=range]::-webkit-slider-runnable-track {
      width: 100%;
      height: 2px;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
    }

    /* Classe para o flash vermelho */
    .alert-red {
      color: #ff3333 !important;
      text-shadow: 0 0 20px #ff0000;
      transform: scale(1.3);
    }

    /* Responsividade */
    @media (max-width: 600px) {
      aside#lateral {
        gap: 1.5rem;
        flex-wrap: wrap;
      }
      .dilema {
        font-size: 1.1rem;
        padding: 1rem;
      }
    }
  </style>
</head>
<body>

  <!-- Campo de distorção -->
  <canvas id="field"></canvas>

  <!-- Conteúdo acima do campo -->
  <main id="content">
    <section id="central">
      <p class="dilema">
        <span class="h2o-tag">H<sub>2</sub>O</span>
        Se eficiência exige mais consumo, até onde eu aceito ir?
      </p>
    </section>

    <!-- Espaçador central implícito pelo grid -->
    <div style="flex-grow: 1;"></div> 

    <aside id="lateral">
      <div class="stat-box">
        <span>Água (L)</span>
        <strong id="agua">0.4700</strong>
      </div>

      <div class="control-box">
        <label for="quality">Densidade</label>
        <input type="range" id="quality" min="1" max="5" step="1" value="3">
      </div>
      
      <!-- Botão de som removido conforme solicitado -->

      <div class="stat-box">
        <span>Energia (kWh)</span>
        <strong id="energia">0.01200</strong>
      </div>
    </aside>
  </main>

  <script>
    /**
     * FIELD.JS - Implementação
     * Cria um campo de partículas conectado que se distorce com o mouse.
     * Calcula o "custo" computacional em tempo real para atualizar os dados.
     */

    const canvas = document.getElementById('field');
    const ctx = canvas.getContext('2d');
    
    // Elementos de DOM para atualização
    const elAgua = document.getElementById('agua');
    const elEnergia = document.getElementById('energia');
    const elQuality = document.getElementById('quality');

    // Estado da simulação
    let width, height;
    let particles = [];
    const mouse = { x: null, y: null, active: false };
    let time = 0; // Adicionado para controlar o tempo da onda
    
    // Configurações da Grid (Valores iniciais baseados no slider = 3)
    let GAP = 40; 
    const RADIUS = 2; 
    let CONNECTION_DIST = 100; 
    const REPEL_DIST = 200; 
    const REPEL_FORCE = 2;

    // Mapa de densidade: [GAP, CONNECTION_DIST, CustoExtra, VolumeGrave]
    // Menor GAP = Mais particulas = Mais linhas = Mais custo
    const qualityLevels = {
      1: { gap: 80, dist: 120, costMult: 0.3, bassVol: 0.6 }, // Leve, som mais baixo
      2: { gap: 60, dist: 110, costMult: 0.6, bassVol: 0.8 },
      3: { gap: 40, dist: 100, costMult: 1.0, bassVol: 1.0 }, // Padrão
      4: { gap: 30, dist: 90,  costMult: 2.5, bassVol: 1.3 },
      5: { gap: 20, dist: 80,  costMult: 6.0, bassVol: 1.6 }  // Extremo, som pesado
    };

    let currentCostMultiplier = 1.0;
    let currentBassMultiplier = 1.0;

    // Estado dos "Recursos"
    let waterConsumption = 0.47;
    let energyConsumption = 0.012;
    let lastWaterInt = 0; // Rastreia o valor inteiro anterior para o flash

    // Fatores de incremento baseados no "stress" da CPU (simulado)
    const baseEnergyRate = 0.0000001; 
    const interactionMultiplier = 50; // Gasta 50x mais "energia" se interagir

    // --- AUDIO SYSTEM ---
    let audioCtx = null;
    let droneNode = null; 
    let droneGain = null;
    let isAudioActive = false;
    let audioStarted = false; // Flag para garantir inicialização única

    // Escala "Aquática" (Modo Dórico ou Pentatônica Menor estendida para fluidez)
    const HYDRO_NOTES = [196.00, 220.00, 261.63, 293.66, 329.63, 392.00, 440.00];

    // Inicializa o contexto de áudio
    function initAudio() {
        if (audioCtx) return;

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();

        // 1. FUNDO: Fluxo de Água (Water Flow Drone)
        const bufferSize = audioCtx.sampleRate * 2;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        
        let lastOut = 0;
        for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            data[i] = (lastOut + (0.02 * white)) / 1.02;
            lastOut = data[i];
            data[i] *= 3.5;
        }

        droneNode = audioCtx.createBufferSource();
        droneNode.buffer = buffer;
        droneNode.loop = true;

        const droneFilter = audioCtx.createBiquadFilter();
        droneFilter.type = 'lowpass';
        droneFilter.frequency.value = 400;

        droneGain = audioCtx.createGain();
        droneGain.gain.value = 0.0; // Começa zerado para fade-in

        droneNode.connect(droneFilter);
        droneFilter.connect(droneGain);
        droneGain.connect(audioCtx.destination);

        droneNode.start();
        
        isAudioActive = true;
        
        // Fade in automático ao iniciar
        droneGain.gain.setTargetAtTime(0.5 * currentBassMultiplier, audioCtx.currentTime, 1.5);
    }

    // Função auxiliar para desbloquear o AudioContext na primeira interação
    function unlockAudio() {
        if (audioStarted) return;
        
        if (!audioCtx) {
            initAudio();
        } else if (audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => {
                isAudioActive = true;
                if(droneGain) {
                    droneGain.gain.setTargetAtTime(0.5 * currentBassMultiplier, audioCtx.currentTime, 1.5);
                }
            });
        }
        
        audioStarted = true;
        
        // Remove os listeners após a primeira interação bem sucedida
        window.removeEventListener('mousemove', unlockAudio);
        window.removeEventListener('touchstart', unlockAudio);
        window.removeEventListener('click', unlockAudio);
    }

    // Função para tocar nota de Hidraulofone
    function playHydroNote() {
        if (!isAudioActive || !audioCtx) return;
        
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        
        const noteFreq = HYDRO_NOTES[Math.floor(Math.random() * HYDRO_NOTES.length)];
        
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(noteFreq, t);
        osc.frequency.exponentialRampToValueAtTime(noteFreq, t + 0.1);

        filter.type = 'bandpass';
        filter.Q.value = 5;
        filter.frequency.setValueAtTime(noteFreq - 100, t);
        filter.frequency.linearRampToValueAtTime(noteFreq + 200, t + 0.3);
        
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.3, t + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 1.5);
        
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();
        lfo.frequency.value = 6;
        lfoGain.gain.value = 5;
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);
        lfo.start(t);
        lfo.stop(t + 1.5);

        osc.start(t);
        osc.stop(t + 1.5); 
    }

    function updateAudio(turbulence) {
        if (!isAudioActive || !audioCtx) return;

        // O fluxo de fundo aumenta com a agitação
        // Agora o volume base depende da densidade (currentBassMultiplier)
        const baseVol = 0.5 * currentBassMultiplier;
        const targetVol = baseVol + (turbulence * 0.5); 
        
        droneGain.gain.setTargetAtTime(targetVol, audioCtx.currentTime, 0.2);
    }
    // --- END AUDIO SYSTEM ---


    // Inicialização
    function init() {
      resize();
      lastWaterInt = Math.floor(waterConsumption);
      updateQuality(elQuality.value);
      animate();
    }

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      createParticles(); // Recria grid ao redimensionar
    }

    function updateQuality(level) {
      const config = qualityLevels[level];
      GAP = config.gap;
      CONNECTION_DIST = config.dist;
      currentCostMultiplier = config.costMult;
      currentBassMultiplier = config.bassVol; // Atualiza o multiplicador de grave
      
      // Reinicia a malha com a nova densidade
      createParticles();
    }

    class Particle {
      constructor(x, y) {
        this.originX = x;
        this.originY = y;
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.friction = 0.96; 
        this.ease = 0.03;
      }

      update() {
        // Lógica de Retorno à Origem
        const dx = this.originX - this.x;
        const dy = this.originY - this.y;
        
        // Interação com Mouse
        if (mouse.active) {
          const mouseDx = mouse.x - this.x;
          const mouseDy = mouse.y - this.y;
          const dist = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);

          if (dist < REPEL_DIST) {
            const angle = Math.atan2(mouseDy, mouseDx);
            const force = (REPEL_DIST - dist) / REPEL_DIST;
            
            const moveX = Math.cos(angle) * force * REPEL_FORCE;
            const moveY = Math.sin(angle) * force * REPEL_FORCE;
            
            this.vx -= moveX;
            this.vy -= moveY;
            
            incrementResources(true); 
          }
        }

        // Física de mola
        this.vx += dx * this.ease;
        this.vy += dy * this.ease;

        // Ondulação constante
        this.vy += Math.sin(this.x * 0.01 + time * 0.02) * 0.05;

        this.vx *= this.friction;
        this.vy *= this.friction;

        this.x += this.vx;
        this.y += this.vy;
      }

      draw() {
        const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
        const alpha = 0.3 + Math.min(speed * 0.1, 0.7);
        
        ctx.fillStyle = `rgba(100, 120, 140, ${alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, RADIUS, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function createParticles() {
      particles = [];
      const cols = Math.ceil(width / GAP);
      const rows = Math.ceil(height / GAP);
      
      // Centraliza a grid
      const offsetX = (width - (cols * GAP)) / 2;
      const offsetY = (height - (rows * GAP)) / 2;

      for (let i = 0; i <= cols; i++) {
        for (let j = 0; j <= rows; j++) {
          particles.push(new Particle(offsetX + i * GAP, offsetY + j * GAP));
        }
      }
    }

    function drawConnections() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
      ctx.lineWidth = 1;
      
      for (let i = 0; i < particles.length; i++) {
        const p1 = particles[i];
        
        for (let j = i + 1; j < particles.length; j++) {
            const p2 = particles[j];
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            
            if (dx * dx + dy * dy < CONNECTION_DIST * CONNECTION_DIST) {
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
        }
      }
    }

    function triggerBlink() {
        elAgua.classList.add('alert-red');
        setTimeout(() => {
            elAgua.classList.remove('alert-red');
        }, 500);
    }

    function incrementResources(isInteracting) {
      // Aplica o multiplicador de custo baseado na densidade escolhida
      let multiplier = (isInteracting ? interactionMultiplier : 1) * currentCostMultiplier;
      
      // Áudio custa processamento extra (dilema)
      if (isAudioActive) multiplier *= 1.2;

      energyConsumption += baseEnergyRate * multiplier;
      waterConsumption += (baseEnergyRate * 1.8) * multiplier; 

      // Verifica se passamos para o próximo litro inteiro
      const currentWaterInt = Math.floor(waterConsumption);
      if (currentWaterInt > lastWaterInt) {
          triggerBlink();
          lastWaterInt = currentWaterInt;
      }

      elEnergia.innerText = energyConsumption.toFixed(7);
      elAgua.innerText = waterConsumption.toFixed(6);
    }

    function animate() {
      ctx.clearRect(0, 0, width, height);

      time++; 

      // Custo base de existir 
      incrementResources(false);

      let totalVelocity = 0;

      particles.forEach(p => {
        p.update();
        p.draw();
        // Soma velocidade absoluta para modular o som
        totalVelocity += Math.abs(p.vx) + Math.abs(p.vy);
      });
      
      // Média de "agitação" da tela
      const avgTurbulence = totalVelocity / particles.length;
      updateAudio(avgTurbulence);
      
      // --- SISTEMA DE SOM ---
      if (isAudioActive) {
          // Chance baseada na turbulência (água agitada gera som)
          const noteChance = 0.01 + (avgTurbulence * 0.15); 
          // Limita disparos para não virar ruído caótico
          if (Math.random() < noteChance && Math.random() > 0.5) {
              playHydroNote();
          }
      }
      
      drawConnections();

      requestAnimationFrame(animate);
    }

    // Event Listeners
    window.addEventListener('resize', resize);
    
    // Listener do Slider
    elQuality.addEventListener('input', (e) => {
      updateQuality(parseInt(e.target.value));
    });
    
    // Configura o "Unlock" do áudio na primeira interação do usuário (mouse ou toque)
    window.addEventListener('mousemove', unlockAudio, { once: true });
    window.addEventListener('touchstart', unlockAudio, { once: true });
    window.addEventListener('click', unlockAudio, { once: true });

    // Captura movimento do mouse 
    window.addEventListener('mousemove', (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      mouse.active = true;
      
      clearTimeout(mouse.timer);
      mouse.timer = setTimeout(() => {
        mouse.active = false;
      }, 2000);
    });

    // Suporte a toque
    window.addEventListener('touchmove', (e) => {
      const touch = e.touches[0];
      mouse.x = touch.clientX;
      mouse.y = touch.clientY;
      mouse.active = true;
    });

    init();

  </script>
</body>
</html>

